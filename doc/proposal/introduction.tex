\section{Introduction}

Software systems today are large and incomprehensible.
This is due in part to the difficulty
of interfacing with computer hardware.
In particular, the translation of high-level programming
languages to low-level machine code
is a challenge -- one that is exacerbated by
the complex and idiosyncratic
computer architectures and operating systems that are common today.

We propose a simple, machine-level intermediate language to make
the process of compilation more manageable.
To be generally useful, the language is independent of any
machine or programming language in particular.
This makes the language similar to the original
UNCOL (UNiversal Computer Oriented Language)~\cite{strong1958problem},
but with a different focus.

\subsection{Advantages}
%\subsection{Simplifying Language Implementation}

\emph{Breaking down the compilation task makes it more manageable.}
The programming language compiler is responsible for
lowering the semantics of a program to a machine-level,
but the machine code generator is left with the job of register allocation,
instruction selection, implementing platform ABI and so forth.
%Using a low-level intermediate language leaves compiler writers free to
%focus on lowering the semantics of a program to a machine-level,
%without concern for the arbitrary complexity that modern hardware and operating systems impose.

\emph{A uniform and parsimonious language is an easier compilation target.}
%This is not because it presents a high-level of computation, but
%because it is uniform and parsimonious.
%This in turn enables simplicity in software components that
These qualities enable simplicity in the software components that
produce code in our language, and in the components that %(execute or)
generate machine code from our language.

\emph{A clean, machine-level model of computation is useful.}
Low-level program execution can be easily virtualized and visualized.
This can lead to insight that helps not only those first learning
this layer of a system, but also those actively working at that level.

\emph{Decoupling from hardware facilitates portable software.}
By isolating platform details in one software component,
portability is more easily achieved.
Our interest, though, is limited to the most common platforms -- namely
the x86 and ARM computer architectures and the Mac OS X, Windows and
Linux operating systems.

\subsection{Not Goals}

Perhaps what most distinguishes our effort
are the aspirations that we don't have.

\emph{Efficiency is not a goal}.
Most intermediate languages for machine code generation
are designed with a focus on efficiency --
efficient execution, efficient use of memory, efficient compilation.
We deliberately ignore these concerns because more efficient designs
are usually more complex.

\emph{Wide portability is not a goal.}
Although portability is one purpose of the language, we intend
to support only the few machine architectures and operating systems
mentioned above. Limiting the target platforms allows many important,
simplifying assumptions to be made.

\emph{To facilitate writing programs in the language is not a goal.}
Assembly languages often provide features
to help people write code.
As code in our language is intended to be generated
by a compiler, including such features would only complicate our language.
Therefore, there are no macro facilities, high-level commands,
or pseudo-instructions meant to make it easier for a person to write code.
For this same reason, language extensibility is not a goal.
